接下来 我们看一下在实际代码当中
一个系统调用的引用到最后的实现
在这我们可以看到在我们ucore里头
我这里演示的ucore
实际上我们用的是ucore+代码
和我们现在同学们做实验ucore会有一些区别
为了有所区别 所以我在这演示的时候
用的是ucore+
以便同学在里头做的时候需自己去找一遍
在你那个系统里头他的函数的实现情况
在这里一个例子 在这个例子就有一句去读文件
在这里后面有参数 这是一个应用态的一个测试应例
他在里面去访问的 我们看一下这read个函数
他调用其他调用其他函数情况
这有很多例子会调用read
然后他会调sys read然后是sys call
这两个函数在往下就没有了
这个转过来到这sys read实际上就是转变成sys call
然后这个时候你的函数功能变成这里一个参数
后面内容都变 这是sys call函数
然后sys call函数实现在哪
实现在这 我们看到这是sys call实现
前面有一些相应的参数获取
然后对于我们来说
我们需要关心代码是这段
这是在X86情况下他的系统调用
这是num是我们刚在PPT里看到的
是他的系统调用的编号
这是系统调用的中段号 这是系统调用
到这我们从用户态的情况
在往下就已经跟踪不到了
我们转过身来在内核态
内核态我们刚才在PPT里说
他是从all trap到trap然后在我们这里我们先看trap
这里头实际上就是从中段进来之后
他填了一个数据结构叫trapframe
在这个数据结构当中
是获取到了相应中段产生的一些信息
他里面有我们说的中段号和相应寄存器的值
到这就转到trap dispatch 这我们可以看到其中有一个sys call
他会判断trap num是多少
根据不同情况我们关心的是在这里的sys call
如果说你是其他 比如说时钟终断
那在这里他的时间代码在这
我们关心到这 他到sys call这个函数
这个函数我们看一下这是他函数调用图
我们trap dispatch到这是sys call然后这个sys call实际下去之后
在里面有很多内容 我们看直接代码
这是sys call 到这来之后 他会转到sys read
到这会去读取你的参数
这实际上就是从系统调用进来之后
获取他一二三 这三个参数
然后这个时候转过之后变成sys write
我们看到这来的时候 这是sys read到sys write
然后再往下就是相应的实现了
我们看在这sys write到这里最后下去之后
我们带这里根据不同情况完成相应文件的读取工作
在这里实际我在介绍中间还缺了一段
就是从trap再往前那段
和sys dispatch到sys read这段我在这没做展示
希望大家下去之后能够把
相应的整个从用户态到内核态
然后到函数的实现 一直到返回
把整个这条路分析明白
那这样你就知道一个系统调用是如何实现的
好今天的课就上到这里 下课